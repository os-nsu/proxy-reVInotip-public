# Процессы (lab3)

## Теоретические вопросы
    1. Что такое fork(2) и что он делает?
    2. Что такое clone(2) и что он делает?
    3. Состояния процесса. Состояние zombie и зачем оно нужно?
    4. Как получить код возврата процесса и что этот код из себя представляет?
    5. Что находится в proc, proc/stat?
    6. Процесс init, зачем он нужен.
    7. Что происходит с дочерними процессами, если родительский умирает?
    8. Сигнал SIGCHLD. Зачем он нужен и в каких случаях приходит?

## Задания (порядок выполнения не важен)
    1. Реализовать функцию void register_worker(...) в соответсвии с интерфейсом.
        a. Эта функция должна создавать процесс, который начнёт выполнятся с переданной ему функции.
        b. Параметры, которые в неё передаются, должны быть где-то сохранены вместе с pid-ом процесса и
            удалены только при его окночательном завершении.
        c. Основной процесс должен посылать сигнал SIGTERM своим дочерним процессам при завершении.
            Коды возврата дочерних процессов должны корректно обрабатываться.
    2. Написать плагин с названием task_manager, использующий функцию register_worker для создания процесса.
        a. Функция, которая будет запущена в новом процессе должна просто возвращать ноль.
        b. Напишите обработчик сигнала SIGTERM так, чтобы при получении этого сигнала код возврата был 0.

## Ожидаемое поведение программы

 - Если дочерний процесс завершился раньше завершения основного цикла программы, то поведение должно соответствовать
 значению параметра функции *register_worker* - **restart**, заданному при создании процесса.
 - При завершении основного цилка программы (даже если он был завершён некорректно, например по сигналу) нужно завершить все
 дочерние процессы, проанализировать код возврата каждого из них и освободить все связанные с ними ресурсы.

### Обработка ошибок

 - Если при работе функции *register_worker* **не получилось** создать новый процесс то необходимо
 написать в лог сообщение:

        "Can not create new worker's process for plugin: %s\n", ${имя_плагина_для_которого_создавался_процесс}.
    После этого необходимо освободить все вспомогательные ресурсы (такие как стуркутруы), предназанченные для этого процесса и вернуть код -1.
    Основной цикл программы при этом не завершается и продолжает пытаться создать процессы для следующих плагинов.
 - Если при заврешении основного цикла во время завершения дочерних процессов некторые из них завершатся с кодом возврата, отличным от нуля,
 или по сигналу то необходимо вывести в лог сообщение:

        "Worker's process %s with %d and finished with non zero code: %d\n", ${имя_процесса}, ${pid}, ${код_завершения} - в случае не нулевого кода,
        "Worker's process %s with %d and terminated by signal: %d\n", ${имя_процесса}, ${pid}, ${номер_сигнала} - в случае завершения по сигналу
    После этого основной процесс продолжает процедуру завершения работы остальных процессов.
 - Если при попытке перезапуска дочернего процесса произошла ошибка, то необходимо вывести в лог сообщение:

        "Can not start worker's process with pid: %d and name: %s", ${pid}, ${имя_процесса}
    При этом по попытки перезапустить процесс должны продолжаться с тем же таймаутом.
 - Если дочерний процесс завершился с ошибкой раньше основного цикла, то не зависимо от необходимости его перезапуска
 нужно вывести в лог сообщение:

        "Worker's process %s with %d finished with non zero code: %d\n", ${имя_процесса}, ${pid}, ${код_завершения} - в случае не нулевого кода,
        "Worker's process %s with %d terminated by signal: %d\n", ${имя_процесса}, ${pid}, ${номер_сигнала} - в случае завершения по сигналу

### Журнал сообщений

 - Если все операции по созданию процессов завершились успешно, то необходимо вывести в лог сообщение с уровнем LOG_INFO:

        "All worker's processes created successfully\n".
 - Если при завершении основного цикла все дочерние процессы завершились без ошибок, то необходимо вывести в лог сообщение с уровнем
 LOG_INFO:

        "All worker's processes terminated successfully\n".
 - Если дочерний процесс завершился с кодом ноль раньше основного цикла и при этом установлен перезапуск только в случае ошибки
 (IF_ERROR), то необходимо вывести в лог следующее сообщение:

        "Worker's process %s with %d finished successfully\n", ${имя_процесса}, ${pid}

## Требования к устойчивости

    Все ресурсы при заверешнии должны корректно освобождаться (в том числе при сбоях в работе),
    дочерние процессы должны восстанавливаться если это необходимо, должна быть корректная обработка сигналов.

## Интерфейс и струтура проекта

### Файл master.h

#### Типы:

<table>
  <thead>
    <tr>
      <th style="text-align: left;">Название типа</th>
      <th style="text-align: left;">Метатип</th>
      <th style="text-align: left;">Состав</th>
      <th style="text-align: left;">Описание</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: left;"><b>RestartConstants</b></td>
      <td style="text-align: left;"><b>enum</b></td>
      <td style="text-align: left;">
        <b>NEVER</b> = 0 - Никогда не перезапускать<br>
        <b>ALWAYS</b> = 1 - Всегда пытаться перезапустить<br>
        <b>IF_ERROR</b> = 2 - Перезапускать если процесс завершился по сигналу или
            с кодом возрата, отличным от нуля
      </td>
      <td style="text-align: left;"><b>Определяет поведение при перезапуске процесса</b></td>
    </tr>
  </tbody>
</table>

#### Функции:

<table>
    <thead>
        <tr>
            <th>Название</th>
            <th>Описание</th>
            <th>Аргументы</th>
            <th>Возвращаемое значение</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td><b>register_worker</b></td>
            <td>Создаёт новый процесс для плагина</td>
            <td>
                <b>[in] const char* name</b> Имя созданваемого процесса<br>
                <b>[in] const char* lib_name</b> Имя плагина (имя библиотеки) без ".so" в конце<br>
                <b>[in] const char* func_name</b> Точка входа для процесса (имя функции, с которой начнётся её выполнение)<br>
                <b>[in] RestartConstants restart</b> Определяет поведение при заверешении этого процесса<br>
                <b>[in] uint32_t cooldownt</b> В случае, если restart != NEVER определяет промежуток времени в секундах
                    через который процесс будет перезапущен
            </td>
            <td><b>void</td>
        </tr>
    </tbody> 
</table>